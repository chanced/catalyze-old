use super::{
    Descriptor, EnumDescriptor, FieldDescriptor, ServiceDescriptor, SourceCodeInfo,
    UninterpretedOption,
};

pub struct FileDescriptorSet {
    pub files: Vec<FileDescriptor>,
}

/// Describes a complete .proto file.
#[derive(Clone, Debug, PartialEq)]
pub struct FileDescriptor {
    /// file name, relative to root of source tree
    name: Option<String>,
    /// e.g. "foo", "foo.bar", etc.
    package: Option<String>,
    /// Names of files imported by this file.
    dependencies: Vec<String>,
    /// Indexes of the public imported files in the dependency list above.
    public_dependency: Vec<i32>,
    /// Indexes of the weak imported files in the dependency list.
    /// For Google-internal migration only. Do not use.
    weak_dependency: Vec<i32>,
    /// All top-level definitions in this file.
    message_types: Vec<Descriptor>,
    enum_types: Vec<EnumDescriptor>,
    services: Vec<ServiceDescriptor>,
    extensions: Vec<FieldDescriptor>,
    options: Option<FileOptions>,
    /// This field contains optional information about the original source code.
    /// You may safely remove this entire field without harming runtime
    /// functionality of the descriptors -- the information is needed only by
    /// development tools.
    source_code_info: Option<SourceCodeInfo>,
    /// The syntax of the proto file.
    /// The supported values are "proto2" and "proto3".
    syntax: Option<String>,
}
#[derive(Clone, Debug, PartialEq)]
pub struct FileOptions {
    /// Sets the Java package where classes generated from this .proto will be
    /// placed.  By default, the proto package is used, but this is often
    /// inappropriate because proto packages do not normally start with backwards
    /// domain names.
    java_package: Option<String>,
    /// If set, all the classes from the .proto file are wrapped in a single
    /// outer class with the given name.  This applies to both Proto1
    /// (equivalent to the old "--one_java_file" option) and Proto2 (where
    /// a .proto always translates to a single class, but you may want to
    /// explicitly choose the class name).
    java_outer_classname: Option<String>,
    /// If set true, then the Java code generator will generate a separate .java
    /// file for each top-level message, enum, and service defined in the .proto
    /// file.  Thus, these types will *not* be nested inside the outer class
    /// named by java_outer_classname.  However, the outer class will still be
    /// generated to contain the file's getDescriptor() method as well as any
    /// top-level extensions defined in the file.
    java_multiple_files: Option<bool>,
    /// This option does nothing.
    java_generate_equals_and_hash: Option<bool>,
    /// If set true, then the Java2 code generator will generate code that
    /// throws an exception whenever an attempt is made to assign a non-UTF-8
    /// byte sequence to a string field.
    /// Message reflection will do the same.
    /// However, an extension field still accepts non-UTF-8 byte sequences.
    /// This option has no effect on when used with the lite runtime.
    java_string_check_utf8: Option<bool>,
    // #[prost(
    //     enumeration = "file_options::OptimizeMode",
    //     optional,
    //     tag = "9",
    //     default = "Speed"
    // )]
    optimize_for: Option<i32>,
    /// Sets the Go package where structs generated from this .proto will be
    /// placed. If omitted, the Go package will be derived from the following:
    ///   - The basename of the package import path, if provided.
    ///   - Otherwise, the package statement in the .proto file, if present.
    ///   - Otherwise, the basename of the .proto file, without extension.
    // #[prost(string, optional, tag = "11")]
    go_package: Option<String>,
    /// Should generic services be generated in each language?  "Generic" services
    /// are not specific to any particular RPC system.  They are generated by the
    /// main code generators in each language (without additional plugins).
    /// Generic services were the only kind of service generation supported by
    /// early versions of google.protobuf.
    ///
    /// Generic services are now considered deprecated in favor of using plugins
    /// that generate code specific to your particular RPC system.  Therefore,
    /// these default to false.  Old code which depends on generic services should
    /// explicitly set them to true.
    // #[prost(bool, optional, tag = "16", default = "false")]
    cc_generic_services: Option<bool>,
    // #[prost(bool, optional, tag = "17", default = "false")]
    java_generic_services: Option<bool>,
    // #[prost(bool, optional, tag = "18", default = "false")]
    py_generic_services: Option<bool>,
    // #[prost(bool, optional, tag = "42", default = "false")]
    php_generic_services: Option<bool>,
    /// Is this file deprecated?
    /// Depending on the target platform, this can emit Deprecated annotations
    /// for everything in the file, or it will be completely ignored; in the very
    /// least, this is a formalization for deprecating files.
    // #[prost(bool, optional, tag = "23", default = "false")]
    deprecated: Option<bool>,
    /// Enables the use of arenas for the proto messages in this file. This applies
    /// only to generated classes for C++.
    // #[prost(bool, optional, tag = "31", default = "true")]
    cc_enable_arenas: Option<bool>,
    /// Sets the objective c class prefix which is prepended to all objective c
    /// generated classes from this .proto. There is no default.
    // #[prost(string, optional, tag = "36")]
    objc_class_prefix: Option<String>,
    /// Namespace for generated classes; defaults to the package.
    // #[prost(string, optional, tag = "37")]
    csharp_namespace: Option<String>,
    /// By default Swift generators will take the proto package and CamelCase it
    /// replacing '.' with underscore and use that to prefix the types/symbols
    /// defined. When this options is provided, they will use this value instead
    /// to prefix the types/symbols defined.
    // #[prost(string, optional, tag = "39")]
    swift_prefix: Option<String>,
    /// Sets the php class prefix which is prepended to all php generated classes
    /// from this .proto. Default is empty.
    // #[prost(string, optional, tag = "40")]
    php_class_prefix: Option<String>,
    /// Use this option to change the namespace of php generated classes. Default
    /// is empty. When this option is empty, the package name will be used for
    /// determining the namespace.
    // #[prost(string, optional, tag = "41")]
    php_namespace: Option<String>,
    /// Use this option to change the namespace of php generated metadata classes.
    /// Default is empty. When this option is empty, the proto file name will be
    /// used for determining the namespace.
    // #[prost(string, optional, tag = "44")]
    php_metadata_namespace: Option<String>,
    /// Use this option to change the package of ruby generated classes. Default
    /// is empty. When this option is not set, the package name will be used for
    /// determining the ruby package.
    // #[prost(string, optional, tag = "45")]
    ruby_package: Option<String>,
    /// The parser stores options it doesn't recognize here.
    /// See the documentation for the "Options" section above.
    // #[prost(message, repeated, tag = "999")]
    uninterpreted_option: ::prost::alloc::vec::Vec<UninterpretedOption>,
}

// /// file name, relative to root of source tree
// pub fn name(&self) -> Option<String> {
//     self.name.clone()
// }
// /// e.g. "foo", "foo.bar", etc.
// pub fn package(&self) -> Option<String> {
//     self.package.clone()
// }
// /// Names of files imported by this file.
// pub fn dependency(&self) -> &[String] {
//     &self.dependency
// }
